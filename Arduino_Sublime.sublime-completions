{"scope":"source.c","completions":[{"trigger":"abs","contents":"abs(${1:x});","annotation":"Calculates the absolute value of a number.","kind":"markup"},{"trigger":"analogRead","contents":"analogRead(${1:pin});","annotation":"Reads the value from the specified analog pin.","kind":"markup"},{"trigger":"analogWrite","contents":"analogWrite(${1:pin}, ${2:value});","annotation":"Writes an analog value to a pin.","kind":"markup"},{"trigger":"arduino","contents":"void setup()\n{\n\t$0\n}\n\nvoid loop()\n{\n\t","annotation":"Builds the body of an arduino program.","kind":"markup"},{"trigger":"byte","contents":"byte(${1:x});","annotation":"Converts a value to the byte data type.","kind":"markup"},{"trigger":"char","contents":"char(${1:x});","annotation":"Converts a value to the char data type.","kind":"markup"},{"trigger":"constrain","contents":"constrain(${1:x}, ${2:a}, ${3:b});","annotation":"Constrains a number to be within a range.","kind":"markup"},{"trigger":"define","contents":"define ${1:IDENTIFIER} ${2:string}","annotation":"Directive that causes the compiler to substitute token-string for each occurrence of identifier in the source file","kind":"markup"},{"trigger":"delay","contents":"delay(${1:ms});","annotation":"Pauses the program for the amount of time (in milliseconds) specified as parameter. (There are 1000 milliseconds in a second.)","kind":"markup"},{"trigger":"delayMicroseconds","contents":"delayMicroseconds(${1:us});","annotation":"Pauses the program for the amount of time (in microseconds) specified as parameter.","kind":"markup"},{"trigger":"detachInterrupt","contents":"detachInterrupt(${1:interrupt});","annotation":"Turns off the given interrupt.","kind":"markup"},{"trigger":"digitalRead","contents":"digitalRead(${1:pin});","annotation":"Reads the value from a specified digital pin, either HIGH or LOW.","kind":"markup"},{"trigger":"digitalWrite","contents":"digitalWrite(${1:pin}, ${2:value});","annotation":"Write a HIGH or a LOW value to a digital pin.","kind":"markup"},{"trigger":"dowhile","contents":"do{\n    ${1:// statement block}\n} while (${2:test condition});","annotation":"The do…​while loop works in the same manner as the while loop, with the exception that the condition is tested at the end of the loop, so the do loop will always run at least once","kind":"markup"},{"trigger":"float","contents":"float(${1:x});","annotation":"Converts a value to the float data type.","kind":"markup"},{"trigger":"for","contents":"for(int ${1:i}=0; ${1:i}<${2}; ${1}++){\n    ${3}\n}","annotation":"The for statement is used to repeat a block of statements enclosed in curly braces.","kind":"markup"},{"trigger":"if","contents":"if(${1}){\n    ${2}\n}","annotation":"The if statement checks for a condition and executes the proceeding statement or set of statements if the condition is 'true'.","kind":"markup"},{"trigger":"ifdef","contents":"ifdef ${1:constant-expression}","annotation":"The #ifdef directive checks for the existence of macro definitions.","kind":"markup"},{"trigger":"ifndef","contents":"ifndef ${1:constant-expression}","annotation":"The #ifdef directive checks for the inexistence of macro definitions.","kind":"markup"},{"trigger":"include","contents":"include <${1:lib.h}>","annotation":"#include is used to include outside libraries in your sketch.","kind":"markup"},{"trigger":"int","contents":"int(${1:x});","annotation":"Converts a value to the int data type.","kind":"markup"},{"trigger":"long","contents":"long(${1:x});","annotation":"Converts a value to the long data type.","kind":"markup"},{"trigger":"loop","contents":"void loop()\n{\n\t$1\n}","annotation":"The loop() function does precisely what its name suggests, and loops consecutively, allowing your program to change and respond.","kind":"markup"},{"trigger":"map","contents":"map(${1:value}, ${2:fromLow}, ${3:fromHigh}, ${4:toLow}, ${5:toHigh});","annotation":"Re-maps a number from one range to another. That is, a value of fromLow would get mapped to toLow, a value of fromHigh to toHigh, values in-between to values in-between, etc.","kind":"markup"},{"trigger":"max","contents":"max(${1:x}, ${2:y});","annotation":"Calculates the maximum of two numbers.","kind":"markup"},{"trigger":"elif","contents":"elif ${1:constant-expression}","annotation":"Macro elif","kind":"markup"},{"trigger":"micros","contents":"micros();","annotation":"Returns the number of microseconds since the Arduino board began running the current program.","kind":"markup"},{"trigger":"millis","contents":"millis();","annotation":"Returns the number of milliseconds since the Arduino board began running the current program.","kind":"markup"},{"trigger":"min","contents":"min(${1:x}, ${2:y});","annotation":"Calculates the minimum of two numbers.","kind":"markup"},{"trigger":"noTone","contents":"noTone(${1:pin});","annotation":"Stops the generation of a square wave triggered by tone(). Has no effect if no tone is being generated.","kind":"markup"},{"trigger":"pinMode","contents":"pinMode(${1:pin}, ${2:mode});","annotation":"Configures the specified pin to behave either as an input or an output.","kind":"markup"},{"trigger":"pow","contents":"pow(${1:base}, ${2:exponent});","annotation":"Calculates the value of a number raised to a power. Pow() can be used to raise a number to a fractional power. This is useful for generating exponential mapping of values or curves.","kind":"markup"},{"trigger":"pulseIn","contents":"pulseIn(${1:pin}, ${2:value}, ${3:timeout});","annotation":"Reads a pulse on a pin. Waits for the pin state change, starts timing, then waits for the pin to go change again and stops timing. Returns the length of the pulse in microseconds or gives up and returns 0 if no complete pulse was received within the timeout.","kind":"markup"},{"trigger":"random","contents":"random(${1:min}, ${2:max});","annotation":"The random function generates pseudo-random numbers.","kind":"markup"},{"trigger":"randomSeed","contents":"randomSeed(${1:seed});","annotation":"Initializes the pseudo-random number generator. To initialize the random number generator with a fairly random input, such as analogRead() on an unconnected pin.","kind":"markup"},{"trigger":"savailable","contents":"if (Serial.available() > ${1:0}) {\n    ${2}\n}","annotation":"Get the number of bytes (characters) available for reading from the serial port.","kind":"markup"},{"trigger":"sbegin","contents":"Serial.begin(${1:9600});","annotation":"Sets the data rate in bits per second (baud) for serial data transmission. An optional second argument configures the data, parity, and stop bits. The default is 8 data bits, no parity, one stop bit.","kind":"markup"},{"trigger":"send","contents":"Serial.end();","annotation":"Disables serial communication, allowing the RX and TX pins to be used for general input and output. To re-enable serial communication, call Serial.begin().","kind":"markup"},{"trigger":"sevent","contents":"void serialEvent(){\n    ${1://statements}\n}","annotation":"Called when data is available. Use Serial.read() to capture this data.","kind":"markup"},{"trigger":"sfind","contents":"Serial.find(${1:target});","annotation":"Serial.find() reads data from the serial buffer until the target string of given length is found. The function returns true if target string is found, false if it times out.","kind":"markup"},{"trigger":"sfindUntil","contents":"Serial.findUntil(${1:target}, ${2:terminal});","annotation":"Serial.findUntil() reads data from the serial buffer until a target string of given length or terminator string is found.","kind":"markup"},{"trigger":"sflush","contents":"Serial.flush();","annotation":"Waits for the transmission of outgoing serial data to complete.","kind":"markup"},{"trigger":"spfloat","contents":"Serial.parseFloat();","annotation":"Serial.parseFloat() returns the first valid floating point number from the Serial buffer. Characters that are not digits (or the minus sign) are skipped.","kind":"markup"},{"trigger":"spint","contents":"Serial.parseInt();","annotation":"Looks for the next valid integer in the incoming serial stream.","kind":"markup"},{"trigger":"speek","contents":"Serial.peek();","annotation":"Returns the next byte (character) of incoming serial data without removing it from the internal serial buffer.","kind":"markup"},{"trigger":"sprint","contents":"Serial.print(${1:val}, ${2:format});","annotation":"Prints data to the serial port as human-readable ASCII text.","kind":"markup"},{"trigger":"sprint","contents":"Serial.println(${1:val}, ${2:format});","annotation":"Prints data to the serial port as human-readable ASCII text followed by a carriage return character and a newline character","kind":"markup"},{"trigger":"sread","contents":"Serial.read();","annotation":"Reads incoming serial data.","kind":"markup"},{"trigger":"sreadBytes","contents":"Serial.readBytes(${1:buffer}, ${2:length});","annotation":"Serial.readBytes() reads characters from the serial port into a buffer. The function terminates if the determined length has been read, or it times out.","kind":"markup"},{"trigger":"sreadBytesUntil","contents":"Serial.readBytesUntil(${1:character}, ${2:buffer}, ${2:length});","annotation":"Serial.readBytesUntil() reads characters from the serial buffer into an array. The function terminates if the terminator character is detected, the determined length has been read, or it times out.","kind":"markup"},{"trigger":"stimeout","contents":"Serial.setTimeout(${1:time});","annotation":"Serial.setTimeout() sets the maximum milliseconds to wait for serial data when using serial.readBytesUntil() or serial.readBytes(). It defaults to 1000 milliseconds.","kind":"markup"},{"trigger":"swrite","contents":"Serial.write(${1:data});","annotation":"Writes binary data to the serial port. This data is sent as a byte or series of bytes.","kind":"markup"},{"trigger":"setup","contents":"void setup()\n{\n\t$1\n}","annotation":"The setup() function is called when a sketch starts.","kind":"markup"},{"trigger":"shiftIn","contents":"shiftIn(${1:dataPin}, ${2:clockPin}, ${3:bitOrder});","annotation":"Shifts in a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit.","kind":"markup"},{"trigger":"shiftOut","contents":"shiftOut(${1:dataPin}, ${2:clockPin}, ${3:bitOrder}, ${4:value});","annotation":"Shifts out a byte of data one bit at a time. Starts from either the most (i.e. the leftmost) or least (rightmost) significant bit.","kind":"markup"},{"trigger":"sizeof","contents":"sizeof(${1:variable});","annotation":"The sizeof operator returns the number of bytes in a variable type, or the number of bytes occupied by an array.","kind":"markup"},{"trigger":"sqrt","contents":"sqrt(${1:x});","annotation":"Calculates the square root of a number.","kind":"markup"},{"trigger":"switch","contents":"switch (${1}) {\n    case ${2}:\n      ${3:// do something}\n      break;\n    case ${4}:\n      ${5:// do something}\n      break;\n    default:\n      ${6:// do something}\n}","annotation":"Switch statement","kind":"markup"},{"trigger":"tone","contents":"tone(${1:pin}, ${2:frequency}, ${3:duration});","annotation":"Generates a square wave of the specified frequency (and 50% duty cycle) on a pin. A duration can be specified, otherwise the wave continues until a call to noTone().","kind":"markup"},{"trigger":"undef","contents":"undef ${1:constant-expression}","annotation":"Macro undef","kind":"markup"},{"trigger":"while","contents":"while(${1}){\n    ${2:// statement}\n}","annotation":"While statement","kind":"markup"},{"trigger":"sq","contents":"sq(${1:x});","annotation":"Calculates the square of a number: the number multiplied by itself.","kind":"markup"},{"trigger":"analogreadresolution","contents":"analogReadResolution(${1:bits});","annotation":"Sets the size (in bits) of the value returned by analogRead().","kind":"markup"},{"trigger":"analogwriteresolution","contents":"analogReadResolution(${1:bits});","annotation":"Sets the resolution of the analogWrite() function. It defaults to 8 bits.","kind":"markup"},{"trigger":"attachinterrupt","contents":"attachInterrupt(digitalPinToInterrupt(${1:pin}), ${2:function}, ${3:mode});","annotation":"Digital Pins With Interrupts.","kind":"markup"},{"trigger":"interrupts","contents":"interrupts();","annotation":"Re-enables interrupts (after they’ve been disabled by nointerrupts(). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.","kind":"markup"},{"trigger":"nointerrupts","contents":"noInterrupts();","annotation":"Disables interrupts (you can re-enable them with interrupts()). Interrupts allow certain important tasks to happen in the background and are enabled by default. Some functions will not work while interrupts are disabled, and incoming communication may be ignored. Interrupts can slightly disrupt the timing of code, however, and may be disabled for particularly critical sections of code.","kind":"markup"},{"trigger":"bit","contents":"bit(${1:n});","annotation":"Computes the value of the specified bit","kind":"markup"},{"trigger":"bitclear","contents":"bitClear(${1:x}, ${2:n});","annotation":"Clears (writes a 0 to) a bit of a numeric variable.","kind":"markup"},{"trigger":"bitread","contents":"bitRead(${1:x}, ${2:n});","annotation":"Reads a bit of a number.","kind":"markup"},{"trigger":"bitset","contents":"bitSet(${1:x}, ${2:n});","annotation":"Sets (writes a 1 to) a bit of a numeric variable.","kind":"markup"},{"trigger":"bitwrite","contents":"bitWrite(${1:x}, ${2:n}, ${3:b});","annotation":"Writes a bit of a numeric variable.","kind":"markup"},{"trigger":"highbyte","contents":"highByte(${1:x});","annotation":"Extracts the high-order (leftmost) byte of a word (or the second lowest byte of a larger data type).","kind":"markup"},{"trigger":"lowbyte","contents":"lowByte(${1:x});","annotation":"Extracts the low-order (rightmost) byte of a variable (e.g. a word).","kind":"markup"},{"trigger":"isalpha","contents":"isAlpha(${1:thisChar});","annotation":"Analyse if a char is alpha (that is a letter). Returns true if thisChar contains a letter.","kind":"markup"},{"trigger":"isalphanumeric","contents":"isAlphaNumeric(${1:thisChar});","annotation":"Analyse if a char is alphanumeric (that is a letter or a numbers). Returns true if thisChar contains either a number or a letter.","kind":"markup"},{"trigger":"isascii","contents":"isAscii(${1:thisChar});","annotation":"Analyse if a char is Ascii. Returns true if thisChar contains an Ascii character.","kind":"markup"},{"trigger":"iscontrol","contents":"isControl(${1:thisChar});","annotation":"Analyse if a char is a control character. Returns true if thisChar is a control character.","kind":"markup"},{"trigger":"isdigit","contents":"isDigit(${1:thisChar});","annotation":"Analyse if a char is a digit (that is a number). Returns true if thisChar is a number.","kind":"markup"},{"trigger":"isgraph","contents":"isGraph(${1:thisChar});","annotation":"Analyse if a char is printable with some content (space is printable but has no content). Returns true if thisChar is printable.","kind":"markup"},{"trigger":"ishexadecimaldigit","contents":"isHexadecimalDigit(${1:thisChar});","annotation":"Analyse if a char is an hexadecimal digit (A-F, 0-9). Returns true if thisChar contains an hexadecimal digit.","kind":"markup"},{"trigger":"islowerCase","contents":"isLowerCase(${1:thisChar});","annotation":"Analyse if a char is lower case (that is a letter in lower case). Returns true if thisChar contains a letter in lower case.","kind":"markup"},{"trigger":"isprintable","contents":"isPrintable(${1:thisChar});","annotation":"Analyse if a char is printable (that is any character that produces an output, even a blank space). Returns true if thisChar is printable.","kind":"markup"},{"trigger":"ispunct","contents":"isPunct(${1:thisChar});","annotation":"Analyse if a char is punctuation (that is a comma, a semicolon, an exlamation mark and so on). Returns true if thisChar is punctuation.","kind":"markup"},{"trigger":"isspace","contents":"isSpace(${1:thisChar});","annotation":"Analyse if a char is the space character. Returns true if thisChar contains the space character.","kind":"markup"},{"trigger":"isuppercase","contents":"isUpperCase(${1:thisChar});","annotation":"Analyse if a char is upper case (that is, a letter in upper case). Returns true if thisChar is upper case.","kind":"markup"},{"trigger":"iswhitespace","contents":"isWhitespace(${1:thisChar});","annotation":"Analyse if a char is a white space, that is space, formfeed, newline, carriage return, horizontal tab, and vertical tab. Returns true if thisChar contains a white space.","kind":"markup"},{"trigger":"cos","contents":"cos(${1:rad});","annotation":"Calculates the cosine of an angle (in radians). The result will be between -1 and 1.","kind":"markup"},{"trigger":"sin","contents":"sin(${1:rad});","annotation":"Calculates the sine of an angle (in radians). The result will be between -1 and 1.","kind":"markup"},{"trigger":"tan","contents":"tan(${1:rad});","annotation":"Calculates the tangent of an angle (in radians). The result will be between negative infinity and infinity.","kind":"markup"},{"trigger":"toint","contents":"toInt();","annotation":"Converts a valid String to an integer. The input String should start with an integer number. If the String contains non-integer numbers, the function will stop performing the conversion.","kind":"markup"},{"trigger":"c_str","contents":"c_str();","annotation":"Converts the contents of a string as a C-style, null-terminated string. Note that this gives direct access to the internal String buffer and should be used with care. In particular, you should never modify the string through the pointer returned. When you modify the String object, or when it is destroyed, any pointer previously returned by c_str() becomes invalid and should not be used any longer.","kind":"markup"},{"trigger":"charat","contents":"charAt(${1:n});","annotation":"Access a particular character of the String.","kind":"markup"},{"trigger":"compareto","contents":"compareTo(${1:string2});","annotation":"Compares two Strings, testing whether one comes before or after the other, or whether they’re equal. The strings are compared character by character, using the ASCII values of the characters. That means, for example, that 'a' comes before 'b' but after 'A'. Numbers come before letters.","kind":"markup"},{"trigger":"concat","contents":"concat(${1:parameter});","annotation":"Appends the parameter to a String.","kind":"markup"},{"trigger":"endswith","contents":"endsWith(${1:string2});","annotation":"Tests whether or not a String ends with the characters of another String.","kind":"markup"},{"trigger":"equals","contents":"equals(${1:string2});","annotation":"Compares two strings for equality. The comparison is case-sensitive, meaning the String (hello) is not equal to the String (HELLO).","kind":"markup"},{"trigger":"equalsignorecase","contents":"equalsIgnoreCase(${1:string2});","annotation":"Compares two Strings for equality. The comparison is not case-sensitive, meaning the String (hello) is equal to the String(HELLO).","kind":"markup"},{"trigger":"getbytes","contents":"getBytes(${1:buf}, ${2:len});","annotation":"Copies the String’s characters to the supplied buffer.","kind":"markup"},{"trigger":"indexof","contents":"indexOf(${1:val}, ${2:from});","annotation":"Locates a character or String within another String. By default, searches from the beginning of the String, but can also start from a given index, allowing for the locating of all instances of the character or String.","kind":"markup"},{"trigger":"lastindexof","contents":"lastIndexOf(${1:val}, ${2:from});","annotation":"Locates a character or String within another String. By default, searches from the end of the String, but can also work backwards from a given index, allowing for the locating of all instances of the character or String.","kind":"markup"},{"trigger":"length","contents":"length();","annotation":"Returns the length of the String, in characters. (Note that this doesn’t include a trailing null character.)","kind":"markup"},{"trigger":"remove","contents":"remove(${1:index}, ${2:cont});","annotation":"Modify in place a String removing chars from the provided index to the end of the String or from the provided index to index plus count.","kind":"markup"},{"trigger":"replace","contents":"replace(${1:substring1}, ${2:substring2});","annotation":"The String replace() function allows you to replace all instances of a given character with another character. You can also use replace to replace substrings of a String with a different substring.","kind":"markup"},{"trigger":"reserve","contents":"reserve(${1:size});","annotation":"The String reserve() function allows you to allocate a buffer in memory for manipulating Strings.","kind":"markup"},{"trigger":"setcharat","contents":"setCharAt(${1:index}, ${2:c});","annotation":"Sets a character of the String. Has no effect on indices outside the existing length of the String.","kind":"markup"},{"trigger":"startswith","contents":"startsWith(${1:string2});","annotation":"Tests whether or not a String starts with the characters of another String.","kind":"markup"},{"trigger":"substring","contents":"substring(${1:from}, ${2:to});","annotation":"Get a substring of a String. The starting index is inclusive (the corresponding character is included in the substring), but the optional ending index is exclusive (the corresponding character is not included in the substring). If the ending index is omitted, the substring continues to the end of the String.","kind":"markup"},{"trigger":"tochararray","contents":"toCharArray(${1:buf}, ${2:len});","annotation":"Copies the String’s characters to the supplied buffer.","kind":"markup"},{"trigger":"tofloat","contents":"toFloat();","annotation":"Converts a valid String to a float. The input String should start with a digit. If the String contains non-digit characters, the function will stop performing the conversion. For example, the Strings 123.45, 123, and 123fish are converted to 123.45, 123.00, and 123.00 respectively. Note that 123.456 is approximated with 123.46. Note too that floats have only 6-7 decimal digits of precision and that longer Strings might be truncated.","kind":"markup"},{"trigger":"tolowercase","contents":"toLowerCase();","annotation":"Get a lower-case version of a String. As of 1.0, toLowerCase() modifies the String in place rather than returning a new one.","kind":"markup"},{"trigger":"touppercase","contents":"toUpperCase();","annotation":"Get an upper-case version of a String. As of 1.0, toUpperCase() modifies the String in place rather than returning a new one.","kind":"markup"},{"trigger":"trim","contents":"trim();","annotation":"Get a version of the String with any leading and trailing whitespace removed. As of 1.0, trim() modifies the String in place rather than returning a new one.","kind":"markup"},{"trigger":"struct","contents":"struct ${1:type_name} {\n\t${2:// Data members}\n\n\t}${3:// types, *types}\n;","annotation":"It enables the programmer to create a variable that structures a selected set of data.","kind":"markup"},{"trigger":"class","contents":"class ${1:type_name}\n{\n\tpublic:\n\t\t${1:type_name}(${2:type_variable});\n\t\t${3:// Data members}\n\n\tprivate:\n\t\t${4:// Data members}\n};\n\n${1:type_name} :: ${1:type_name}\n{\n\t${5:// Data members}\n}\n${6:// More Fuctions}\n","annotation":" It is a user defined data type, which holds its own data members and member functions, which can be accessed and used by creating an instance of that class.","kind":"markup"}]}